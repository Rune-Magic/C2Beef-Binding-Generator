using System;
using System.IO;
using System.Interop;
using System.Collections;
using System.Diagnostics;

using LibClang;

namespace Rune.CBindingGenerator;

static class CBindings
{
	/// args passed to clang, should always include '--language=c' or '-x c'
	public static Span<char8*> args = char8*[?]("--language=c");

	public enum Flags { None = 0, VulkanLike = 1 }
	public class LibraryInfo
	{
		public Flags flags = .None;

		/// the suffix for the opaque types used in handles (will be _T for vulkan)
		public StringView handleOpaqueTypeSuffix;

		/// all cursors with this spelling will be excluded
		public Span<StringView> blackList = default;

		/// custom attributes applied to extern functions and function pointers
		/// e.g. CallingConvention(.StdCall)
		public StringView customFunctionAttributes = "";

		/// custom attributes applied only applied to extern functions
		/// e.g. Import("library.dll")
		public StringView customLinkage = "";

		/// the functions will be put in the returned type via extensions
		/// if null is returned the default block will be used ('static' or empty)
		public delegate StringView?(CXCursor cursor, StringView spelling) getBlock = null;

		/// can be used to modify spellings of cursors and types
		/// if non trimming modification are done, then allocate a new strBuffer object
		/// NOTE: do NOT directly change the char data of `spelling'
		/// @see_also CBindings.ModifySourceName
		public delegate void(CXCursor cursor, ref StringView spelling, out String strBuffer) modifySourceName = null;

		/// like modifySourceSpelling but for enum cases
		public delegate void(ref StringView spelling, StringView parentSpelling, out String strBuffer) modifyEnumCaseSpelling = null;
	}

	protected static volatile CXIndex index = Clang.CreateIndex(1, 1) ~ Clang.DisposeIndex(_);

	public static void Generate(char8* header, StringView outputFile, StringView outputNamespace, LibraryInfo library, params Span<StringView> usingDepedencies)
	{
		CXTranslationUnit_Flags unitFlags = .SkipFunctionBodies | .DetailedPreprocessingRecord;
		let unit = Clang.ParseTranslationUnit(index, header, args.Ptr, (.)args.Length, null, 0, (.)unitFlags);
		if (unit == null) Runtime.FatalError(scope $"Failed to parse {StringView(header)}");
		defer Clang.DisposeTranslationUnit(unit);

		String output = scope .(32768);
		String lastDecls = scope .(256);
		output.Append("""
			/* Auto generated by https://github.com/Rune-Magic/c-to-beef-binding-generator
			 * DO NOT EDIT
			 */


			""");
		for (let dependency in usingDepedencies)
			output.Append("using ", dependency, ";\n");
		if (usingDepedencies.Length > 1) output.Append('\n');
		output.Append("""
			using System;
			using System.Interop;

			namespace
			""", " ", outputNamespace, ";\n\n");

		bool newLine = false;
		String blockName = scope .();
		Clang.VisitChildren(Clang.GetTranslationUnitCursor(unit), (cursor, parent, data) =>
		{
			(String output, bool* newLine, char8* header, CXTranslationUnit unit, LibraryInfo library, String blockName, String lastDecls) = *(.)data;

			Clang.GetSpellingLocation(Clang.GetCursorLocation(cursor), let file, ?, ?, ?);
			let filename = GetString!(Clang.GetFileName(file));
			if (filename == null || !String.Equals(filename, header)) return .Continue;

			if (!library.blackList.IsEmpty)
			{
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				for (let blackListed in library.blackList)
					if (spelling == blackListed) return .Continue;
			}

			Cursor(cursor, output, library, unit, "", blockName, lastDecls, newLine, includeAttrs: true, noEnsureBlock: false);

			return .Continue;
		}, &(output, &newLine, header, unit, library, blockName, lastDecls));

		if (!blockName.IsEmpty)
			output.Append("}\n");

		File.WriteAllText(outputFile, output);
	}

	protected static mixin GetString(CXString str)
	{
		defer:mixin Clang.DisposeString(str);
		Clang.GetCString(str)
	}

	protected static void ModifySourceName(CXCursor cursor, ref StringView spelling, LibraryInfo library, out String strBuffer)
	{
		strBuffer = null;
		if (spelling.EndsWith('_')) spelling.RemoveFromEnd(1);
		library.modifySourceName?.Invoke(cursor, ref spelling, out strBuffer);
	}

	protected static bool IsOutParam(CXType paramType, LibraryInfo library, StringView paramSpelling, StringView lastParamSpelling, StringView docs)
	{
		return (paramType.kind == .Pointer && Clang.GetPointeeType(paramType).kind != .Void && (
			(library.flags.HasFlag(.VulkanLike)
				&& Clang.IsConstQualifiedType(Clang.GetPointeeType(paramType)) == 0
				&& !(paramSpelling.EndsWith('s') && paramSpelling.StartsWith('p') && lastParamSpelling.EndsWith("Count", .OrdinalIgnoreCase)))));
	}

	protected static void FillOutParams(CXComment docs, bool[] outParams, Span<StringView> args)
	{
		let childCount = Clang.Comment_GetNumChildren(docs);
		for (let i < childCount)
		{
			let child = Clang.Comment_GetChild(docs, i);
			if (Clang.Comment_GetKind(child) != .ParamCommand) continue;
			if (Clang.ParamCommandComment_GetDirection(child) != .Out)
			{
				// me when clang doesn't follow it's own docstring syntax rules ._.
				let paragraph = Clang.BlockCommandComment_GetParagraph(child);
				if (Clang.Comment_GetNumChildren(paragraph) == 0) continue;
				let paragraphChild = Clang.Comment_GetChild(paragraph, 0);
				if (Clang.Comment_GetKind(paragraphChild) != .Text) continue;
				StringView paragraphText = .(GetString!(Clang.TextComment_GetText(paragraphChild)));
				if (!paragraphText..TrimStart().StartsWith("[out]")) continue;
			}
			if (Clang.ParamCommandComment_IsParamIndexValid(child) != 0)
			{
				outParams[Clang.ParamCommandComment_GetParamIndex(child)] = true;
				continue;
			}

			StringView param = .(GetString!(Clang.ParamCommandComment_GetParamName(child)));
			for (let arg in args)
				if (arg == param)
				{
					outParams[@arg.Index] = true;
					break;
				}
		}
	}


	static StringView GetAttributes(CXCursor cursor)
	{
		switch (cursor.kind)
		{
		case .StructDecl:	return "CRepr";
		case .UnionDecl:	return "Union, CRepr";
		case .EnumDecl:		return "CRepr, AllowDuplicates";
		default:			return null;
		}
	}

	protected static void Type(CXType type, String output, LibraryInfo library, bool includeAttrsInAnon = false)
	{
		let typeDecl = Clang.GetTypeDeclaration(type);
		if (Clang.Cursor_IsAnonymous(typeDecl) != 0)
		{
			bool newLine = false;
			Cursor(typeDecl, output, library, null, "\t", .Empty, null, &newLine, inlinedType: true, includeAttrs: includeAttrsInAnon);
			output.TrimEnd();
			return;
		}

		switch (type.kind)
		{
		case .Void: output.Append("void");
		case .Bool: output.Append("bool");
		case .UChar, .Char_U: output.Append("c_uchar");
		case .Char16: output.Append("int16");
		case .Char32: output.Append("int32");
		case .UShort: output.Append("c_ushort");
		case .UInt: output.Append("c_uint");
		case .ULong: output.Append("c_ulong");
		case .ULongLong: output.Append("c_ulonglong");
		case .Char_S, .SChar: output.Append("c_char");
		case .WChar: output.Append("c_wchar");
		case .Short: output.Append("c_short");
		case .Int: output.Append("c_int");
		case .Long: output.Append("c_long");
		case .LongLong: output.Append("c_longlong");
		case .Float: output.Append("float");
		case .Double: output.Append("double");
		case .Pointer:
			let pointee = Clang.GetPointeeType(type);
			Type(pointee, output, library, true);
			if (pointee.kind != .FunctionNoProto && pointee.kind != .FunctionProto)
				output.Append("*");
		case .IncompleteArray:
			let elementType = Clang.GetArrayElementType(type);
			Type(elementType, output, library, true);
			output.Append('*');
		case .LValueReference: output.Append("ref "); Type(Clang.GetPointeeType(type), output, library, true);
		case .RValueReference: output.Append("in "); Type(Clang.GetPointeeType(type), output, library, true);
		case .Record, .Enum:
			StringView name = .(GetString!(Clang.GetTypeSpelling(type)));
			ModifySourceName(typeDecl, ref name, library, let toDelete);
			output.Append(name);
			delete toDelete;
		case .FunctionNoProto:
			output.Append("function ");
			Type(Clang.GetResultType(type), output, library, true);
			output.Append("()");
		case .FunctionProto:
			output.Append("function ");
			Type(Clang.GetResultType(type), output, library, true);
			let argc = Clang.GetNumArgTypes(type);
			output.Append('(');
			for (let i < argc)
			{
				if (i > 0) output.Append(", ");
				Type(Clang.GetArgType(type, (.)i), output, library, true);
			}
			output.Append(')');
		case .ConstantArray:
			Type(Clang.GetArrayElementType(type), output, library, true);
			output..Append('[')..Append(Clang.GetArraySize(type))..Append(']');
		case .Elaborated, .Typedef:
			let str = Clang.GetTypeSpelling(type);
			defer Clang.DisposeString(str);
			StringView spelling = .(Clang.GetCString(str));
			ModifySourceName(typeDecl, ref spelling, library, let toDelete);
			defer delete toDelete;
			while (true)
			{
				mixin Prefix(StringView prefix)
				{
					if (spelling.StartsWith(prefix))
					{
						spelling.RemoveFromStart(prefix.Length);
						continue;
					}
				}

				Prefix!("const ");
				Prefix!("struct ");
				Prefix!("enum ");
				Prefix!("union ");
				break;
			}

			switch (spelling)
			{
			case "int8_t": output.Append("int8");
			case "int16_t": output.Append("int16");
			case "int32_t": output.Append("int32");
			case "int64_t": output.Append("int64");
			case "uint8_t": output.Append("uint8");
			case "uint16_t": output.Append("uint16");
			case "uint32_t": output.Append("uint32");
			case "uint64_t": output.Append("uint64");
			case "wchar_t": output.Append("c_wchar");
			case "size_t": output.Append("c_size");
			case "intptr_t": output.Append("c_intptr");
			case "uintptr_t": output.Append("c_uintptr"); 
			case "va_list": output.Append("VarArgs");
			default: output.Append(_);
			}
		default:
			Runtime.FatalError(scope $"Type {_} is not supported");
		}
	}

	protected static void Cursor(CXCursor cursor, String output, LibraryInfo library, CXTranslationUnit unit, StringView baseIndent, String blockName, String lastDecls, bool* newLine, bool inlinedType = false, bool includeAttrs = false, bool noEnsureBlock = true)
	{
		static bool DocString(String output, CXCursor cursor, bool newLine, StringView indent)
		{
			bool nonParsedCommand = false;
			int lastTextNewLineIdx = -1;
			bool Comment(CXComment comment)
			{
				switch (Clang.Comment_GetKind(comment))
				{
				case .Null: return false;
				case .Text:
					StringView str = .(GetString!(Clang.TextComment_GetText(comment)))..TrimStart();
					if (str == "@" || str == "\\")
					{
						if (lastTextNewLineIdx > 0)
							output.RemoveToEnd(lastTextNewLineIdx);
						output.Append('@');
						nonParsedCommand = true;
					}
					else
					{
						output.Append(str);
						if (nonParsedCommand)
						{
							output.Append(' ');
							nonParsedCommand = false;
							lastTextNewLineIdx = -1;
						}
						else
						{
							lastTextNewLineIdx = output.Length;
							output.Append('\n');
						}
					}
				case .InlineCommand:
					if (lastTextNewLineIdx > 0)
						output.RemoveToEnd(lastTextNewLineIdx);
					output..Append('@')..Append(GetString!(Clang.InlineCommandComment_GetCommandName(comment)));
					let argc = Clang.InlineCommandComment_GetNumArgs(comment);
					for (let i < argc)
						output..Append(' ')..Append(GetString!(Clang.InlineCommandComment_GetArgText(comment, i)));
					if (Clang.InlineContentComment_HasTrailingNewline(comment) != 0)
					{
						lastTextNewLineIdx = output.Length;
						output.Append('\n');
					}
					else
					{
						output.Append(' ');
						nonParsedCommand = true;
					}
				case .HTMLStartTag, .HTMLEndTag:
					output.Append(GetString!(Clang.HTMLTagComment_GetAsString(comment)));
				case .BlockCommand:
					output..Append('@')..Append(GetString!(Clang.BlockCommandComment_GetCommandName(comment)))..Append(' ');
					let argc = Clang.BlockCommandComment_GetNumArgs(comment);
					for (let i < argc)
						output..Append(GetString!(Clang.BlockCommandComment_GetArgText(comment, i)))..Append(' ');
					Comment(Clang.BlockCommandComment_GetParagraph(comment));
				case .ParamCommand:
					output..Append("@param ")..Append(GetString!(Clang.ParamCommandComment_GetParamName(comment)))..Append(' ');
					Comment(Clang.BlockCommandComment_GetParagraph(comment));
				case .TParamCommand:
					output..Append("@tparam ")..Append(GetString!(Clang.TParamCommandComment_GetParamName(comment)))..Append(' ');
					Comment(Clang.BlockCommandComment_GetParagraph(comment));
				case .VerbatimBlockLine:
					StringView str = .(GetString!(Clang.VerbatimBlockLineComment_GetText(comment)));
					if (str.StartsWith(' ')) str.RemoveFromStart(1);
					if (str.StartsWith(' ')) str.RemoveFromStart(1);
					if (str.StartsWith(' ')) str.RemoveFromStart(1);
					output..Append(str)..Append('\n');
				case .VerbatimLine:
					output..Append(GetString!(Clang.VerbatimLineComment_GetText(comment)))..Append('\n');
				case .FullComment, .VerbatimBlockCommand, .Paragraph:
					switch (_)
					{
					case .FullComment:
						output.Append(indent, "/** ");
						defer:: output.Append(indent, " */\n");
					case .VerbatimBlockCommand:
						output.Append("```\n");
						defer:: output.Append(indent, " *  ```\n");
					default:
					}

					let childCount = Clang.Comment_GetNumChildren(comment);
					for (let i < childCount)
					{
						if (output.EndsWith('\n')) output.Append(indent, " *  ");
						Comment(Clang.Comment_GetChild(comment, i));
					}
					if (!output.EndsWith('\n')) output.Append('\n');
				}
				return true;
			}
			return Comment(Clang.Cursor_GetParsedComment(cursor));
		}

		static bool AddSpelling(CXCursor cursor, LibraryInfo library, String output, String lastDecls = null)
		{
			if (Clang.Cursor_IsAnonymous(cursor) != 0) return false;
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView modified = .(spelling);
			ModifySourceName(cursor, ref modified, library, let toDelete);
			defer delete toDelete;
			Compiler.Identifier.GetSourceName(modified, output);
			if (lastDecls != null)
			{
				if (lastDecls.Length + modified.Length + 1 > 256)
					lastDecls.Remove(0, modified.Length + 1);
				lastDecls..Append(';')..Append(modified);
			}
			return spelling.Length != modified.Length;
		}

		String indentStr = scope .(baseIndent.Length + 1), doubleIndentStr = scope .(baseIndent.Length + 2);
		StringView indent = ?, doubleIndent = ?;
		void EnsureBlock(StringView block)
		{
			defer
			{
				indentStr.Set(baseIndent);
				doubleIndentStr..Set(baseIndent).Append('\t');
				if (!blockName.IsEmpty)
				{
					indentStr.Append('\t');
					doubleIndentStr.Append('\t');
				}
				indent = indentStr;
				doubleIndent = doubleIndentStr;
			}
			if (noEnsureBlock || blockName == block) return;
			if (!blockName.IsEmpty) output.Append("}\n\n");
			else if (*newLine) output.Append('\n');
			do
			{
				if (block == "static") output.Append("static");
				else if (block.IsEmpty) break;
				else output.Append("extension ", block);
				output.Append("\n{\n");
			}
			blockName.Set(block);
			*newLine = false;
		}

		switch (cursor.kind)
		{
		case .FunctionDecl:
			readonly StringView original = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView modified = .(original);
			ModifySourceName(cursor, ref modified, library, let toDelete);
			defer delete toDelete;
			let block = library.getBlock?.Invoke(cursor, original);
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);
			output.Append(indent);
			let resultType = Clang.GetCursorResultType(cursor);
			{
				output.Append('[');
				bool first = true;
				mixin Comma()
				{
					if (!first) output.Append(", ");
					first = false;
				}

				if (!library.customLinkage.IsEmpty) { Comma!(); output.Append(library.customLinkage); }
				if (!library.customFunctionAttributes.IsEmpty) { Comma!(); output.Append(", ", library.customFunctionAttributes); }
				Comma!();
				if (original != modified)
					output..Append("LinkName(\"", original, "\")");
				else
					output.Append("CLink");
				let resultTypeDecl = Clang.GetTypeDeclaration(resultType);
				if (Clang.Cursor_IsAnonymous(resultTypeDecl) != 0)
				{
					let attrs = GetAttributes(resultTypeDecl);
					if (!attrs.IsNull) { Comma!(); output.Append(attrs); }
				}
			}
			output.Append("] public static extern ");
			Type(resultType, output, library);
			output.Append(' ');
			if (Compiler.Identifier.sReservedNameSet.ContainsAlt(modified))
				output.Append('@');
			output.Append(modified, "(");
			uint32 argc = (.)Clang.Cursor_GetNumArguments(cursor);
			StringView docs = .(GetString!(Clang.Cursor_GetRawCommentText(cursor)));

			bool[] outParams = scope .[argc];
			outParams:
			{
				StringView[] argSpelling = scope .[argc];
				CXString[] cxStrings = scope .[argc];
				for (let i < argc)
				{
					cxStrings[i] = Clang.GetCursorSpelling(Clang.Cursor_GetArgument(cursor, i));
					argSpelling[i] = .(Clang.GetCString(cxStrings[i]));
				}
				FillOutParams(Clang.Cursor_GetParsedComment(cursor), outParams, argSpelling);
				for (let str in cxStrings)
					Clang.DisposeString(str);
			}

			CXString lastParamString = ?;
			StringView lastParamSpelling = "";
			for (let i < argc)
			{
				if (i > 0) output.Append(", ");
				let param = Clang.Cursor_GetArgument(cursor, i);
				let paramString = Clang.GetCursorSpelling(param);
				StringView paramSpelling = .(Clang.GetCString(paramString));
				var paramType = Clang.GetCursorType(param);
				var paramTypeDecl = Clang.GetTypeDeclaration(paramType);
				{
					bool outParam = false;
					if (outParams[i] || IsOutParam(paramType, library, paramSpelling, lastParamSpelling, docs)) do
					{
						outParam = true;
						paramType = Clang.GetPointeeType(paramType);
					}
					if (Clang.Cursor_IsAnonymous(paramTypeDecl) != 0)
					{
						let attrs = GetAttributes(paramTypeDecl);
						if (!attrs.IsNull) output.Append("[", attrs, "] ");
					}
					if (outParam) output.Append("out "); // defer is broken :(
				}
				Type(paramType, output, library);
				if (!paramSpelling.IsEmpty)
				{
					output.Append(' ');
					AddSpelling(param, library, output);
				}

				Clang.DisposeString(lastParamString);
				lastParamString = paramString;
				lastParamSpelling = paramSpelling;
			}
			Clang.DisposeString(lastParamString);

			if (Clang.Cursor_IsVariadic(cursor) > 0)
				output.Append(", ...");
			output.Append(");\n");

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .StructDecl, .UnionDecl:
			int count = 0;
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				if (cursor.kind != .FieldDecl) return .Continue;
				int* count = (.)data;
				++ *count;
				return .Continue;
			}, &count);

			if (count == 0)
			{
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				ModifySourceName(cursor, ref spelling, library, let toDelete);
				defer delete toDelete;

				{
					if (spelling.EndsWith(library.handleOpaqueTypeSuffix)) return;

					var extent = Clang.GetCursorExtent(cursor);
					extent.[Friend]end_int_data++;
					CXToken* tokens = null;
					uint32 tokenCount = 0;
					Clang.Tokenize(unit, extent, &tokens, &tokenCount);
					defer Clang.DisposeTokens(unit, tokens, tokenCount);
					if (tokenCount == 3 && String.Equals(";", GetString!(Clang.GetTokenSpelling(unit, tokens[2]))))
						return;
				}

				let block = library.getBlock?.Invoke(cursor, spelling);
				EnsureBlock(block.HasValue ? block.Value : .());
				let hasDoc = DocString(output, cursor, *newLine, indent);
				output.Append(indent);
				if (block.HasValue) output.Append("public ");
				output.Append("struct ", spelling, ";\n");
				if (hasDoc) output.Append('\n');
				*newLine = !hasDoc;
				return;
			}

			bool anonymous = Clang.Cursor_IsAnonymous(cursor) != 0;
			if (anonymous && !inlinedType) return;
			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : .());
			let hasDoc = DocString(output, cursor, *newLine, indent);
			if (!hasDoc && *newLine) output.Append('\n');
			if (!anonymous) output.Append(indent);
			if (includeAttrs) output.Append("[", GetAttributes(cursor), "] ");
			output.Append(block.HasValue ? "public struct " : "struct "); AddSpelling(cursor, library, output, lastDecls); output.Append("\n", indent, "{\n");
			bool putNewLine = false;
			int bitFieldCurrentBlockSize = 0;
			int bitFieldTotalWidth = 0;
			static void DumpBitfield(String output, int* bitFieldCurrentBlockSize, int* bitFieldTotalWidth, CXCursor uniqueSuffix, StringView doubleIndent)
			{
				output.Append(doubleIndent, "private uint");
				(*bitFieldCurrentBlockSize).ToString(output);
				output.Append(" __bitfield_");
				Clang.GetRangeEnd(Clang.GetCursorExtent(uniqueSuffix)).[Friend]int_data.ToString(output);
				output.Append(";\n");

				*bitFieldCurrentBlockSize = 0;
				*bitFieldTotalWidth = 0;
			}
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				(String output, bool* newLine, StringView doubleIndent, LibraryInfo library, CXTranslationUnit unit, int* bitFieldCurrentBlockSize, int* bitFieldTotalWidth) = *(.)data;
				switch (cursor.kind)
				{
				case .FieldDecl:
					let type = Clang.GetCursorType(cursor);
					if (Clang.Cursor_IsBitField(cursor) != 0)
					{
						let hasDoc = DocString(output, cursor, *newLine, doubleIndent);

						let size = Clang.Type_GetSizeOf(type) * 8;
						if (size > *bitFieldCurrentBlockSize)
							*bitFieldCurrentBlockSize = size;

						let width = Clang.GetFieldDeclBitWidth(cursor);
						if (*bitFieldTotalWidth + width > *bitFieldCurrentBlockSize)
							DumpBitfield(output, bitFieldCurrentBlockSize, bitFieldTotalWidth, cursor, doubleIndent);

						if (String.StrLen(GetString!(Clang.GetCursorSpelling(cursor))) > 0)
						{
							output.Append(doubleIndent, "[Bitfield(.Public, .BitsAt(pos: ");
							(*bitFieldTotalWidth).ToString(output);
							output.Append(", bits: ");
							width.ToString(output);
							output.Append("), \"");
							AddSpelling(cursor, library, output);
							output.Append("\")]\n");
						}

						*bitFieldTotalWidth += width;

						if (hasDoc) output.Append('\n');
						*newLine = !hasDoc;
						return .Continue;
					}

					if (*bitFieldTotalWidth > 0)
						DumpBitfield(output, bitFieldCurrentBlockSize, bitFieldTotalWidth, cursor, doubleIndent);

					let hasDoc = DocString(output, cursor, *newLine, doubleIndent);
					output.Append(doubleIndent);
					if (Clang.Cursor_IsAnonymous(Clang.GetTypeDeclaration(type)) != 0)
					{
						let attrs = GetAttributes(Clang.GetTypeDeclaration(type));
						if (!attrs.IsNull) output.Append("[", attrs, "] ");
					}
					output.Append("public ");
					Type(type, output, library);
					output.Append(' '); AddSpelling(cursor, library, output); output.Append(";\n");
					var underlyingType = type;
					findUnderlying: while (true)
						switch (underlyingType.kind)
						{
						case .Pointer:
							underlyingType = Clang.GetPointeeType(underlyingType);
						case .ConstantArray, .IncompleteArray:
							underlyingType = Clang.GetArrayElementType(underlyingType);
						default:
							break findUnderlying;
						}
					let underlyingDecl = Clang.GetTypeDeclaration(underlyingType);
					let srcRange = Clang.GetCursorExtent(cursor);
					let underlyingRange = Clang.GetCursorExtent(underlyingDecl);
					if (Clang.Cursor_IsAnonymous(underlyingDecl) == 0 && srcRange.begin_int_data <= underlyingRange.begin_int_data && srcRange.end_int_data >= underlyingRange.end_int_data)
					{
						bool newLineBuf = false;
						output.Append(doubleIndent, GetAttributes(underlyingDecl), " public ");
						Cursor(underlyingDecl, output, library, unit, "\t", .Empty, null, &newLineBuf);
						output..TrimEnd()..Append('\n');
						if (newLineBuf) output.Append('\n');
					}
					if (hasDoc) output.Append('\n');
					*newLine = !hasDoc;
				case .StructDecl, .UnionDecl:
					output.Append(doubleIndent, "[", GetAttributes(cursor), "] public using ");
					Cursor(cursor, output, library, unit, doubleIndent, .Empty, null, newLine, inlinedType: true);
					output..TrimEnd()..Append(";\n");
				default: return .Continue;
				}
				
				return .Continue;
			}, &(output, &putNewLine, doubleIndent, library, unit, &bitFieldCurrentBlockSize, &bitFieldTotalWidth));
			if (bitFieldTotalWidth > 0)
				DumpBitfield(output, &bitFieldCurrentBlockSize, &bitFieldTotalWidth, cursor, doubleIndent);
			output.Append(indent, "}\n\n");
			*newLine = false;

		case .EnumDecl:
			bool anonymous = Clang.Cursor_IsAnonymous(cursor) != 0 && !inlinedType;
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			let block = library.getBlock?.Invoke(cursor, spelling);
			if (anonymous)
			{
				EnsureBlock(block.HasValue ? block.Value : "static");
			}
			else
			{
				EnsureBlock(block.HasValue ? block.Value : .());
				let hasDoc = DocString(output, cursor, *newLine, indent);
				if (!hasDoc && *newLine) output.Append('\n');
				if (!inlinedType) output.Append(indent);
				if (includeAttrs) output.Append("[", GetAttributes(cursor), "] ");
				output.Append(block.HasValue ? "public enum " : "enum "); AddSpelling(cursor, library, output, lastDecls);
				output.Append(" : "); Type(Clang.GetEnumDeclIntegerType(cursor), output, library, true);
				output.Append("\n", indent, "{\n");
			}
			bool putNewLine = false;
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				if (cursor.kind != .EnumConstantDecl) return .Continue;
				(String output, bool* newLine, StringView indent, LibraryInfo library, bool anonymous, CXTranslationUnit unit, StringView parentSpelling) = *(.)data;
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				String toDelete = null;
				library.modifyEnumCaseSpelling?.Invoke(ref spelling, parentSpelling, out toDelete);
				defer delete toDelete;
				bool hasDoc;
				if (spelling.EndsWith("_MAX_ENUM"))
					hasDoc = false;
				else
					hasDoc = DocString(output, cursor, *newLine, indent);
				output.Append(indent);
				if (anonymous) output.Append("public static c_int ");
				Compiler.Identifier.GetSourceName(spelling, output);
				output..Append(" = ")..Append(Clang.GetEnumConstantDeclValue(cursor));
				if (anonymous)
					output.Append(';');
				else do
				{
					defer output.Append(',');
					CXToken* tokens = null;
					uint32 tokenCount = 0;
					Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokens, &tokenCount);
					defer Clang.DisposeTokens(unit, tokens, tokenCount);
					if (tokenCount < 3) break;
					if (tokenCount == 3 && Clang.GetTokenKind(tokens[2]) == .Literal)
						break;
					output.Append(" /* ");
					for (int tokenIdx = 2; tokenIdx < tokenCount; tokenIdx++)
					{
						StringView spell = .(GetString!(Clang.GetTokenSpelling(unit, tokens[tokenIdx])));
						if (spell == "|") output.Append(" | ");
						else output.Append(spell);
					}
					output.Append(" */");
				}
				output.Append('\n');
				if (hasDoc) output.Append('\n');
				*newLine = !hasDoc;
				return .Continue;
			}, &(output, &putNewLine, (anonymous ? indent : doubleIndent), library, anonymous, unit, spelling));
#unwarn
			if (!anonymous) output.Append(indent, "}\n");
			output.Append('\n');
			*newLine = false;

		case .TypedefDecl:
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView docs = .(GetString!(Clang.Cursor_GetRawCommentText(cursor)));
			let type = Clang.GetTypedefDeclUnderlyingType(cursor);

			if (lastDecls != null && lastDecls.EndsWith(spelling))
				return;

			let block = library.getBlock?.Invoke(cursor, spelling);
			EnsureBlock(block.HasValue ? block.Value : .());
			let accessMod = block.HasValue ? "public " : "";
			bool hasDoc = false;
			switch (type.kind)
			{
			case .Pointer:
				let pointee = Clang.GetPointeeType(type);
				if (pointee.kind case .FunctionNoProto || pointee.kind case .FunctionProto) funcPtr: do
				{
					hasDoc = DocString(output, cursor, *newLine, indent);
					output.Append(indent);
					do
					{
						StringView attrs = null;
						if (Clang.Cursor_IsAnonymous(Clang.GetTypeDeclaration(pointee)) != 0)
							attrs = GetAttributes(Clang.GetTypeDeclaration(Clang.GetResultType(pointee)));
						if (attrs.IsNull && library.customFunctionAttributes.IsEmpty) break;
						output.Append("[");
						if (!attrs.IsNull)
						{
							output.Append(attrs);
							if (!library.customFunctionAttributes.IsEmpty)
								output.Append(", ");
						}
						output.Append(library.customFunctionAttributes, "] ");
					}
					output.Append(accessMod, "function ");
					Type(Clang.GetResultType(pointee), output, library);
					if (pointee.kind case .FunctionNoProto || Clang.GetNumArgTypes(pointee) == 0)
					{
						output.Append(" ", spelling, "();\n");
						break;
					}
					output.Append(" ", spelling, "(");
					let argc = Clang.GetNumArgTypes(pointee);
					CXToken* tokens = null;
					uint32 tokenCount = 0;
					Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokens, &tokenCount);
					defer Clang.DisposeTokens(unit, tokens, tokenCount);
					CXSourceLocation currentLoc = Clang.GetRangeStart(Clang.GetTokenExtent(unit, tokens[0]));
					StringView[] paramNames = scope:funcPtr .[argc];
					int paramNamesCount = 0;
					CXTokenKind lastTokenKind = ?;
					StringView lastSpelling = null;
					while (true)
					{
						let token = Clang.GetToken(unit, currentLoc);
						if (token == null) break;
						defer:funcPtr Clang.DisposeTokens(unit, token, 1);
						StringView tokenSpelling = .(GetString!:funcPtr(Clang.GetTokenSpelling(unit, *token)));
						currentLoc = Clang.GetRangeEnd(Clang.GetTokenExtent(unit, *token));
						if (tokenSpelling == ")") break;
					}
					while (true)
					{
						let token = Clang.GetToken(unit, currentLoc);
						if (token == null) break;
						defer:funcPtr Clang.DisposeTokens(unit, token, 1);
						StringView tokenSpelling = .(GetString!:funcPtr(Clang.GetTokenSpelling(unit, *token)));
						if (tokenSpelling == ";") break;
						else if (tokenSpelling == "," || (tokenSpelling == ")" && !lastSpelling.IsNull))
						{
							if (lastTokenKind case .Identifier)
								paramNames[paramNamesCount++] = lastSpelling;
							else
								paramNames[paramNamesCount++] = "";
						}
						lastSpelling = tokenSpelling;
						lastTokenKind = Clang.GetTokenKind(*token);
						currentLoc = Clang.GetRangeEnd(Clang.GetTokenExtent(unit, *token));
					}
					bool[] outParams = scope .[argc];
					let comment = Clang.Cursor_GetParsedComment(cursor);
					FillOutParams(comment, outParams, paramNames);
					StringView prevParamName = "";
					for (let i < argc)
					{
						if (i > 0) output.Append(", ");
						StringView paramName = i < paramNamesCount ? paramNames[i] :
						{
							let childCount = Clang.Comment_GetNumChildren(comment);
							StringView result = "";
							for (let ii < childCount)
							{
								let child = Clang.Comment_GetChild(comment, ii);
								if (Clang.Comment_GetKind(child) != .ParamCommand ||
									Clang.ParamCommandComment_IsParamIndexValid(child) == 0 ||
									Clang.ParamCommandComment_GetParamIndex(child) != ii) continue;
								result = .(GetString!:funcPtr(Clang.ParamCommandComment_GetParamName(child)));
								break;
							}
							result
						};
						var paramType = Clang.GetArgType(pointee, (.)i);
						attrs:
						{
							bool outParam = false;
							if (outParams[i] || IsOutParam(paramType, library, paramName, prevParamName, docs))
							{
								outParam = true;
								paramType = Clang.GetPointeeType(paramType);
							}
							if (Clang.Cursor_IsAnonymous(Clang.GetTypeDeclaration(type)) != 0)
							{
								let attrs = GetAttributes(Clang.GetTypeDeclaration(paramType));
								if (!attrs.IsNull) output.Append("[", attrs, "] ");
							}
							if (outParam) output.Append("out ");
						}
						Type(paramType, output, library);
						if (!paramName.IsEmpty)
						{
							output.Append(' ');
							Compiler.Identifier.GetSourceName(paramName, output);
						}
						prevParamName = paramName;
					}
					output.Append(");\n");
				}
				else fallthrough;
			default:
				StringView typeStr = Type(type, ..scope .(), library, true);
				if (typeStr == spelling) break;
				hasDoc = DocString(output, cursor, *newLine, indent);
				if (typeStr.EndsWith('*') && StringView(typeStr)..RemoveFromEnd(1).EndsWith(library.handleOpaqueTypeSuffix))
				{
					output.Append(indent, "class ", spelling, " { private this() {} }\n");
					break;
				}
				if (library.flags.HasFlag(.VulkanLike) && (typeStr == "VkFlags" || typeStr == "uint32") && lastDecls != null)
				{
					String str = scope:: .(spelling.Length + 4)..Append(';')..Append(spelling)..Replace("Flags", "FlagBits");
					if (lastDecls.Contains(str)) typeStr = str[1...];
				}
				output.Append(indent, accessMod, "typealias ", spelling, " = ", typeStr, ";\n");
			}
			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .VarDecl:
			let type = Clang.GetCursorType(cursor);
			let linkage = Clang.GetCursorLinkage(cursor);

			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);

			switch (linkage)
			{
			case .External:
				output.Append(indent, "[CLink");
				if (Clang.Cursor_IsAnonymous(Clang.GetTypeDeclaration(type)) != 0)
				{
					let attrs = GetAttributes(Clang.GetTypeDeclaration(type));
					if (!attrs.IsNull) output.Append(", ", attrs);
				}
				output.Append("] public static extern ");
				Type(type, output, library); output.Append(' ');
				AddSpelling(cursor, library, output, lastDecls); output.Append(";\n");
			case .Internal when Clang.IsConstQualifiedType(type) != 0:
				output.Append(indent);
				if (Clang.Cursor_IsAnonymous(Clang.GetTypeDeclaration(type)) != 0)
				{
					let attrs = GetAttributes(Clang.GetTypeDeclaration(type));
					if (!attrs.IsNull) output.Append("[", attrs, "] ");
				}
				output.Append("public const ");
				Type(type, output, library); output.Append(' ');
				AddSpelling(cursor, library, output, lastDecls); output.Append(" = ");

				CXToken* tokens = null;
				uint32 tokenCount = 0;
				Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokens, &tokenCount);
				defer Clang.DisposeTokens(unit, tokens, tokenCount);
				StringView constValue = .(GetString!(Clang.GetTokenSpelling(unit, tokens[tokenCount-1])));
				if (constValue.EndsWith("ULL") && !constValue.EndsWith("NULL"))
					constValue.RemoveFromEnd(1);
				output.Append(constValue, ";\n");
			default:
			}

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .MacroDefinition:
			var extent = Clang.GetCursorExtent(cursor);
			CXToken* tokens = null;
			uint32 tokenCount = 0;
			Clang.Tokenize(unit, extent, &tokens, &tokenCount);
			defer Clang.DisposeTokens(unit, tokens, tokenCount);

			if (tokenCount < 2 || Clang.Cursor_IsMacroFunctionLike(cursor) != 0) return;
			String value = scope .();
			bool hasLiteral = false;
			for (int i = 1; i < tokenCount; i++)
			{
				if (Clang.GetTokenKind(tokens[i]) == .Literal) hasLiteral = true;
				StringView spell = .(GetString!(Clang.GetTokenSpelling(unit, tokens[i])));
				if (spell == ",") value.Append(", ");
				else value.Append(spell);
			}
			if (!hasLiteral) return;

			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);
			output.Append(indent, "public const ");

			if (value[0] == '"') output.Append("c_char*");
			else if (value[0] == '\'') output.Append("c_char");
			else if (value.Contains('.') || value.Contains("f", true)) output.Append("float");
			else if (value.Contains("NULL")) value.Replace("NULL", "null");
			else if (value.Contains("ULL")) { output.Append("uint64"); value.Replace("ULL", ""); }
			else if (value.Contains("(void*)")) output.Append("void*");
			else output.Append(library.flags.HasFlag(.VulkanLike) ? "uint32" : "c_int");

			output..Append(' ')..Append(GetString!(Clang.GetTokenSpelling(unit, tokens[0])))..Append(" = ");
			if (value.Contains('~') || (!library.flags.HasFlag(.VulkanLike) && value == "0x80000000"))
				output.Append("(.)");
			output..Append(value)..Append(";\n");

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		default:
		}
	}
}