using System;
using System.IO;
using System.Interop;
using System.Collections;
using System.Diagnostics;

using LibClang;

namespace Rune.CBindingGenerator;

static class CBindings
{
	public enum Flags { None = 0, VulkanLike = 1 }
	public class LibraryInfo
	{
		public Flags flags { get; set; } = .None;

		/// args passed to clang
		public Span<char8*> args { get; set; } = null;

		/// if true is returned then the cursor will be excluded from the bindings
		public delegate bool(CXCursor cursor, StringView spelling) isBlackListed { get; set; } = null;

		/// if true then the typedef will be a handle and the underlying opaque struct will be excluded
		public delegate bool(CXType type, StringView spelling, StringView typedefSpelling) isHandleUnderlyingOpaque { get; set; } = null;

		/// custom attributes applied to extern functions and function pointers
		/// e.g. CallingConvention(.StdCall)
		public StringView customFunctionAttributes { get; set; } = "";

		/// custom attributes applied only applied to extern functions
		/// e.g. Import("library.dll")
		public StringView customLinkage { get; set; } = "";

		/// the functions will be put in the returned type via extensions
		/// if null is returned the default block will be used ('static' or empty)
		public delegate StringView?(CXCursor cursor, StringView spelling) getBlock { get; set; } = null;

		/// can be used to modify spellings of cursors and types
		/// if non trimming modification are done, then allocate a new strBuffer object
		/// NOTE: do NOT directly change the char data of `spelling'
		/// @see_also CBindings.ModifySourceName
		public delegate void(CXCursor cursor, ref StringView spelling, out String strBuffer) modifySourceName { get; set; } = null;

		/// like modifySourceSpelling but for enum cases
		public delegate void(ref StringView spelling, StringView parentSpelling, out String strBuffer) modifyEnumCaseSpelling { get; set; } = null;

		/// add attributes to the binding declaration
		public delegate bool(CXCursor cursor, StringView spelling, String output) addAttributes { get; set; } = null;

		public enum HandleTopLevelCursor_Result
		{
			/** will continue as normal */ Continue,
			/** same as returning true from isBlackListed */ Skip,
		}

		/// will be called for all cursors that are not children of declarations
		/// @param output set this to a `new String` if you want to write code or null otherwise
		/// @param block if output is not null, then the block this to emit `output` to
		public delegate HandleTopLevelCursor_Result(CXCursor cursor, CXTranslationUnit unit, StringView spelling, out String output, out StringView block) handleTopLevelCursor { get; set; } = null;
	}

	protected static volatile CXIndex index = Clang.CreateIndex(1, 1) ~ Clang.DisposeIndex(_);

	public static void Generate(char8* header, StringView outputFile, StringView outputNamespace, LibraryInfo library, params Span<StringView> usingDepedencies)
	{
		Runtime.Assert(File.Exists(.(header)));
		CXTranslationUnit_Flags unitFlags = .SkipFunctionBodies | .DetailedPreprocessingRecord;
		char8*[] args = scope .[library.args.Length + 1];
		library.args.CopyTo(args);
		args[^1] = "--language=c";
		let unit = Clang.ParseTranslationUnit(index, header, args.Ptr, (.)args.Count, null, 0, (.)unitFlags);
		if (unit == null) Runtime.FatalError(scope $"Failed to parse {StringView(header)}");
		defer Clang.DisposeTranslationUnit(unit);

		String output = scope .(32768);
		String lastDecls = scope .(256);
		output.Append("""
			/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
			 * DO NOT EDIT
			 */


			""");
		for (let dependency in usingDepedencies)
			output.Append("using ", dependency, ";\n");
		if (usingDepedencies.Length > 1) output.Append('\n');
		output.Append("""
			using System;
			using System.Interop;

			namespace
			""", " ", outputNamespace, ";\n\n");

		bool newLine = false;
		String blockName = scope .(8);
		Clang.VisitChildren(Clang.GetTranslationUnitCursor(unit), (cursor, parent, data) =>
		{
			(String output, bool* newLine, char8* header, CXTranslationUnit unit, LibraryInfo library, String blockName, String lastDecls) = *(.)data;

			Clang.GetSpellingLocation(Clang.GetCursorLocation(cursor), let file, ?, ?, ?);
			let filename = GetString!(Clang.GetFileName(file));
			if (filename == null || !String.Equals(filename, header)) return .Continue;

			if (library.isBlackListed != null || library.handleTopLevelCursor != null) do
			{
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				if (library.isBlackListed?.Invoke(cursor, spelling) == true) return .Continue;
				if (library.handleTopLevelCursor == null) break;
				let result = library.handleTopLevelCursor(cursor, unit, spelling, let outString, let block);
				if (outString != null)
				{
					EnsureBlockBase(blockName, block, output, newLine);
					output.Append(outString);
					delete outString;
				}
				if (result case .Skip) return .Continue;
			}

			Cursor(cursor, output, library, unit, "", blockName, lastDecls, newLine, includeAttrs: true, noEnsureBlock: false);

			return .Continue;
		}, &(output, &newLine, header, unit, library, blockName, lastDecls));

		EnsureBlockBase(blockName, "", output, &newLine);
		File.WriteAllText(outputFile, output);
	}

	public static mixin GetString(CXString str)
	{
		defer:mixin Clang.DisposeString(str);
		Clang.GetCString(str)
	}

	protected static void ModifySourceName(CXCursor cursor, ref StringView spelling, LibraryInfo library, out String strBuffer)
	{
		strBuffer = null;
		if (spelling.EndsWith('_')) spelling.RemoveFromEnd(1);

		if (library.modifySourceName != null)
			library.modifySourceName(cursor, ref spelling, out strBuffer);
	}

	protected static bool IsOutParam(CXType paramType, LibraryInfo library, StringView paramSpelling, StringView lastParamSpelling, StringView docs)
	{
		return (paramType.kind == .Pointer && Clang.GetPointeeType(paramType).kind != .Void && (
			(library.flags.HasFlag(.VulkanLike)
				&& Clang.IsConstQualifiedType(Clang.GetPointeeType(paramType)) == 0
				&& !(paramSpelling.EndsWith('s') && paramSpelling.StartsWith('p') && lastParamSpelling.EndsWith("Count", .OrdinalIgnoreCase)))));
	}

	protected static void FillOutParams(CXComment docs, bool[] outParams, Span<StringView> args)
	{
		let childCount = Clang.Comment_GetNumChildren(docs);
		for (let i < childCount)
		{
			let child = Clang.Comment_GetChild(docs, i);
			if (Clang.Comment_GetKind(child) != .ParamCommand) continue;
			if (Clang.ParamCommandComment_GetDirection(child) != .Out)
			{
				// me when clang doesn't follow it's own docstring syntax rules ._.
				let paragraph = Clang.BlockCommandComment_GetParagraph(child);
				if (Clang.Comment_GetNumChildren(paragraph) == 0) continue;
				let paragraphChild = Clang.Comment_GetChild(paragraph, 0);
				if (Clang.Comment_GetKind(paragraphChild) != .Text) continue;
				StringView paragraphText = .(GetString!(Clang.TextComment_GetText(paragraphChild)));
				if (!paragraphText..TrimStart().StartsWith("[out]")) continue;
			}
			if (Clang.ParamCommandComment_IsParamIndexValid(child) != 0)
			{
				outParams[Clang.ParamCommandComment_GetParamIndex(child)] = true;
				continue;
			}

			StringView param = .(GetString!(Clang.ParamCommandComment_GetParamName(child)));
			for (let arg in args)
				if (arg == param)
				{
					outParams[@arg.Index] = true;
					break;
				}
		}
	}


	protected static void GetAttributes(CXCursor cursor, LibraryInfo library, StringView spelling, CXType type, String output, Span<StringView> otherAttrs = default)
	{
		bool attrs = false;
		defer { if (attrs) output.Append(']'); }

		mixin NextAttr()
		{
			if (attrs) output.Append(", ");
			else
			{
				output.Append('[');
				attrs = true;
			}
		}

		for (let attr in otherAttrs)
		{
			if (attr.IsEmpty) continue;
			NextAttr!();
			output.Append(attr);
		}

		void Cursor(CXCursor cursor, StringView spelling)
		{
			switch (cursor.kind)
			{
			case .StructDecl:	NextAttr!(); output.Append("CRepr");
			case .UnionDecl:	NextAttr!(); output.Append("Union, CRepr");
			case .EnumDecl:		NextAttr!(); output.Append("AllowDuplicates");
			default:
			}

			if (library.addAttributes != null)
			{
				String outString = scope .();
				library.addAttributes(cursor, spelling, outString);
				if (!outString.IsEmpty)
				{
					NextAttr!();
					output.Append(outString);
				}
			}
		}

		if (cursor != default)
			Cursor(cursor, spelling);

		if (type.kind != .Invalid)
		{
			let decl = Clang.GetTypeDeclaration(type);
			if (decl.kind == .NoDeclFound || Clang.Cursor_IsAnonymous(decl) == 0) return;
			Cursor(decl, .(GetString!(Clang.GetCursorSpelling(decl))));
		}
	}

	private static void EnsureBlockBase(String oldBlock, StringView newBlock, String output, bool* newLine)
	{
		if (oldBlock == newBlock) return;
		if (!oldBlock.IsEmpty)
		{
			if (output.EndsWith("\n\n")) output.RemoveFromEnd(1);
			output.Append("}\n\n");
		}
		else if (*newLine) output.Append('\n');
		do
		{
			if (newBlock == "static") output.Append("static");
			else if (newBlock.IsEmpty) break;
			else output.Append("extension ", newBlock);
			output.Append("\n{\n");
		}
		oldBlock.Set(newBlock);
		*newLine = false;
	}

	protected static void Type(CXType type, String output, LibraryInfo library, bool includeAttrsInAnon = false)
	{
		let typeDecl = Clang.GetTypeDeclaration(type);
		if (Clang.Cursor_IsAnonymous(typeDecl) != 0)
		{
			bool newLine = false;
			Cursor(typeDecl, output, library, null, "\t", .Empty, null, &newLine, inlinedType: true, includeAttrs: includeAttrsInAnon);
			output.TrimEnd();
			return;
		}

		switch (type.kind)
		{
		case .Void: output.Append("void");
		case .Bool: output.Append("bool");
		case .UChar, .Char_U: output.Append("c_uchar");
		case .Char16: output.Append("int16");
		case .Char32: output.Append("int32");
		case .UShort: output.Append("c_ushort");
		case .UInt: output.Append("c_uint");
		case .ULong: output.Append("c_ulong");
		case .ULongLong: output.Append("c_ulonglong");
		case .Char_S, .SChar: output.Append("c_char");
		case .WChar: output.Append("c_wchar");
		case .Short: output.Append("c_short");
		case .Int: output.Append("c_int");
		case .Long: output.Append("c_long");
		case .LongLong: output.Append("c_longlong");
		case .Float: output.Append("float");
		case .Double: output.Append("double");
		case .Pointer:
			let pointee = Clang.GetPointeeType(type);
			Type(pointee, output, library, true);
			if (pointee.kind != .FunctionNoProto && pointee.kind != .FunctionProto)
				output.Append("*");
		case .IncompleteArray:
			let elementType = Clang.GetArrayElementType(type);
			Type(elementType, output, library, true);
			output.Append('*');
		case .LValueReference: output.Append("ref "); Type(Clang.GetNonReferenceType(type), output, library, true);
		case .RValueReference: output.Append("in "); Type(Clang.GetNonReferenceType(type), output, library, true);
		case .Record, .Enum:
			StringView name = .(GetString!(Clang.GetTypeSpelling(type)));
			ModifySourceName(typeDecl, ref name, library, let toDelete);
			output.Append(name);
			delete toDelete;
		case .FunctionNoProto:
			output.Append("function ");
			Type(Clang.GetResultType(type), output, library, true);
			output.Append("()");
		case .FunctionProto:
			output.Append("function ");
			Type(Clang.GetResultType(type), output, library, true);
			let argc = Clang.GetNumArgTypes(type);
			output.Append('(');
			for (let i < argc)
			{
				if (i > 0) output.Append(", ");
				Type(Clang.GetArgType(type, (.)i), output, library, true);
			}
			output.Append(')');
		case .ConstantArray:
			Type(Clang.GetArrayElementType(type), output, library, true);
			output..Append('[')..Append(Clang.GetArraySize(type))..Append(']');
		case .Elaborated, .Typedef:
			let str = Clang.GetTypeSpelling(type);
			defer Clang.DisposeString(str);
			StringView spelling = .(Clang.GetCString(str));
			while (true)
			{
				mixin Prefix(StringView prefix)
				{
					if (spelling.StartsWith(prefix))
					{
						spelling.RemoveFromStart(prefix.Length);
						continue;
					}
				}

				Prefix!("const ");
				Prefix!("struct ");
				Prefix!("enum ");
				Prefix!("union ");
				break;
			}
			ModifySourceName(typeDecl, ref spelling, library, let toDelete);
			defer delete toDelete;

			switch (spelling)
			{
			case "int8_t": output.Append("int8");
			case "int16_t": output.Append("int16");
			case "int32_t": output.Append("int32");
			case "int64_t": output.Append("int64");
			case "uint8_t": output.Append("uint8");
			case "uint16_t": output.Append("uint16");
			case "uint32_t": output.Append("uint32");
			case "uint64_t": output.Append("uint64");
			case "wchar_t": output.Append("c_wchar");
			case "size_t": output.Append("c_size");
			case "intptr_t": output.Append("c_intptr");
			case "uintptr_t": output.Append("c_uintptr"); 
			case "va_list": output.Append("VarArgs");
			default: output.Append(_);
			}
		default:
			Runtime.FatalError(scope $"Type {_} is not supported");
		}
	}

	protected static void Cursor(CXCursor cursor, String output, LibraryInfo library, CXTranslationUnit unit, StringView baseIndent, String blockName, String lastDecls, bool* newLine, bool inlinedType = false, bool includeAttrs = false, bool noEnsureBlock = true)
	{
		static bool DocString(String output, CXCursor cursor, bool newLine, StringView indent)
		{
			char8 nextChar = 0;
			bool Comment(CXComment comment, int extraIndent, bool topLevel = false)
			{
				mixin PrintNextChar()
				{
					if (nextChar != 0)
					{
						output.Append(nextChar);
						if (nextChar == '\n')
							output..Append(indent, " *  ")..Append(' ', extraIndent);
					}
				}

				switch (Clang.Comment_GetKind(comment))
				{
				case .Null: return false;
				case .Text:
					StringView str = .(GetString!(Clang.TextComment_GetText(comment)))..Trim();
					if (str == "<" || str == "/" || str == ">")
					{
						if (str == "<" && nextChar == ' ')
							output.Append(' ');
						output.Append(str);
						nextChar = str == ">" ? ' ' : 0;
					}
					else if (str == "@" || str == "\\")
					{
						PrintNextChar!();
						output.Append('@');
						nextChar = 0;
					}
					else
					{
						PrintNextChar!();
						output.Append(str);
						nextChar = Clang.InlineContentComment_HasTrailingNewline(comment) == 0 ? ((str.IsEmpty || str[^1].IsLetterOrDigit || str[^1] == ':') ? ' ' : 0) : '\n';
					}
				case .InlineCommand:
					PrintNextChar!();
					output..Append('@')..Append(GetString!(Clang.InlineCommandComment_GetCommandName(comment)));
					let argc = Clang.InlineCommandComment_GetNumArgs(comment);
					for (let i < argc)
						output..Append(' ')..Append(GetString!(Clang.InlineCommandComment_GetArgText(comment, i)));
					nextChar = Clang.InlineContentComment_HasTrailingNewline(comment) == 0 ? ' ' : '\n';
				case .HTMLStartTag, .HTMLEndTag:
					output.Append(GetString!(Clang.HTMLTagComment_GetAsString(comment)));
					nextChar = 0;
				case .BlockCommand:
					StringView cmd = .(GetString!(Clang.BlockCommandComment_GetCommandName(comment)));
					int extra = cmd.Length + 2;
					output..Append('@')..Append(cmd);
					let argc = Clang.BlockCommandComment_GetNumArgs(comment);
					for (let i < argc)
					{
						StringView arg = .(GetString!(Clang.BlockCommandComment_GetArgText(comment, i)));
						output..Append(' ')..Append(arg);
						extra = arg.Length + 1;
					}
					nextChar = ' ';
					Comment(Clang.BlockCommandComment_GetParagraph(comment), extra);
				case .ParamCommand:
					StringView paramName = .(GetString!(Clang.ParamCommandComment_GetParamName(comment)));
					output..Append("@param ")..Append(paramName);
					nextChar = ' ';
					Comment(Clang.BlockCommandComment_GetParagraph(comment), paramName.Length + "@param ".Length + 1);
				case .TParamCommand:
					StringView paramName = .(GetString!(Clang.TParamCommandComment_GetParamName(comment)));
					output..Append("@tparam ")..Append(paramName);
					nextChar = ' ';
					Comment(Clang.BlockCommandComment_GetParagraph(comment), paramName.Length + "@tparam ".Length + 1);
				case .VerbatimBlockLine:
					PrintNextChar!();
					StringView str = .(GetString!(Clang.VerbatimBlockLineComment_GetText(comment)));
					output.Append(str);
					nextChar = '\n';
				case .VerbatimLine:
					PrintNextChar!();
					output..Append('`')..Append(GetString!(Clang.VerbatimLineComment_GetText(comment)))..Append('`');
				case .FullComment, .VerbatimBlockCommand, .Paragraph:
					if (topLevel) PrintNextChar!();
					switch (_)
					{
					case .FullComment:
						if (newLine) output.Append('\n');
						output.Append(indent, "/** ");
						defer:: output.Append("\n", indent, " */\n");
					case .VerbatimBlockCommand:
						output.Append("```");
						nextChar = '\n';
						defer::
						{
							PrintNextChar!();
							output.Append("```");
						}
					case .Paragraph:
						defer:: { nextChar = '\n'; }
					default:
					}

					let childCount = Clang.Comment_GetNumChildren(comment);
					for (let i < childCount)
					{
						Comment(Clang.Comment_GetChild(comment, i), extraIndent, _ case .FullComment);
					}
				}
				return true;
			}
			return Comment(Clang.Cursor_GetParsedComment(cursor), 0);
		}

		static bool AddSpelling(CXCursor cursor, LibraryInfo library, String output, String lastDecls = null)
		{
			if (Clang.Cursor_IsAnonymous(cursor) != 0) return false;
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView modified = .(spelling);
			ModifySourceName(cursor, ref modified, library, let toDelete);
			defer delete toDelete;
			Compiler.Identifier.GetSourceName(modified, output);
			if (lastDecls != null)
			{
				if (lastDecls.Length + modified.Length + 1 > 256)
					lastDecls.Remove(0, modified.Length + 1);
				lastDecls..Append(';')..Append(modified);
			}
			return spelling.Length != modified.Length;
		}

		String indentStr = scope .(baseIndent.Length + 1), doubleIndentStr = scope .(baseIndent.Length + 2);
		StringView indent = ?, doubleIndent = ?;
		void EnsureBlock(StringView block)
		{
			if (!noEnsureBlock)
				EnsureBlockBase(blockName, block, output, newLine);
			indentStr.Set(baseIndent);
			doubleIndentStr..Set(baseIndent).Append('\t');
			if (!blockName.IsEmpty)
			{
				indentStr.Append('\t');
				doubleIndentStr.Append('\t');
			}
			indent = indentStr;
			doubleIndent = doubleIndentStr;
		}

		switch (cursor.kind)
		{
		case .FunctionDecl:
			if (Clang.GetCursorLinkage(cursor) != .External) return;
			readonly StringView original = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView modified = .(original);
			ModifySourceName(cursor, ref modified, library, let toDelete);
			defer delete toDelete;
			let block = library.getBlock?.Invoke(cursor, original);
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);
			output.Append(indent);
			let resultType = Clang.GetCursorResultType(cursor);
			attrs:
			{
				StringView[?] attrs = .(library.customFunctionAttributes, library.customLinkage, "CLink");
				if (original != modified)
					attrs[2] = scope:attrs String("LinkName(\"", original, "\")");
				GetAttributes(cursor, library, original, resultType, output, attrs);
			}
			output.Append(" public static extern ");
			Type(resultType, output, library);
			output.Append(' ');
			if (Compiler.Identifier.sReservedNameSet.ContainsAlt(modified))
				output.Append('@');
			output.Append(modified, "(");
			uint32 argc = (.)Clang.Cursor_GetNumArguments(cursor);
			StringView docs = .(GetString!(Clang.Cursor_GetRawCommentText(cursor)));

			bool[] outParams = scope .[argc];
			outParams:
			{
				StringView[] argSpelling = scope .[argc];
				CXString[] cxStrings = scope .[argc];
				for (let i < argc)
				{
					cxStrings[i] = Clang.GetCursorSpelling(Clang.Cursor_GetArgument(cursor, i));
					argSpelling[i] = .(Clang.GetCString(cxStrings[i]));
				}
				FillOutParams(Clang.Cursor_GetParsedComment(cursor), outParams, argSpelling);
				for (let str in cxStrings)
					Clang.DisposeString(str);
			}

			CXString lastParamString = ?;
			StringView lastParamSpelling = "";
			for (let i < argc)
			{
				if (i > 0) output.Append(", ");
				let param = Clang.Cursor_GetArgument(cursor, i);
				let paramString = Clang.GetCursorSpelling(param);
				StringView paramSpelling = .(Clang.GetCString(paramString));
				var paramType = Clang.GetCursorType(param);
				{
					bool outParam = false;
					if (outParams[i] || IsOutParam(paramType, library, paramSpelling, lastParamSpelling, docs)) do
					{
						outParam = true;
						paramType = Clang.GetPointeeType(paramType);
					}
					GetAttributes(param, library, paramSpelling, paramType, output);
					if (outParam) output.Append("out "); // defer is broken :(
				}
				Type(paramType, output, library);
				if (!paramSpelling.IsEmpty)
				{
					output.Append(' ');
					AddSpelling(param, library, output);
				}

				Clang.DisposeString(lastParamString);
				lastParamString = paramString;
				lastParamSpelling = paramSpelling;
			}
			Clang.DisposeString(lastParamString);

			if (Clang.Cursor_IsVariadic(cursor) > 0)
				output.Append(", ...");
			output.Append(");\n");

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .StructDecl, .UnionDecl:
			int count = 0;
			bool packed = false;
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				if (cursor.kind != .FieldDecl) return .Continue;
				(int* count, bool* packed)  = *(.)data;
				++ *count;
				*packed = *packed || cursor.kind == .PackedAttr;
				return .Continue;
			}, &(&count, &packed));

			if (count == 0) do
			{
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				ModifySourceName(cursor, ref spelling, library, let toDelete);
				defer delete toDelete;

				if (library.isHandleUnderlyingOpaque?.Invoke(Clang.GetCursorType(cursor), spelling, null) == true)
					return;

				let block = library.getBlock?.Invoke(cursor, spelling);
				EnsureBlock(block.HasValue ? block.Value : .());
				let hasDoc = DocString(output, cursor, *newLine, indent);
				output.Append(indent);
				if (block.HasValue) output.Append("public ");
				output.Append("struct ", spelling, ";\n");
				if (hasDoc) output.Append('\n');
				*newLine = false;
				return;
			}

			bool anonymous = Clang.Cursor_IsAnonymous(cursor) != 0;
			if (anonymous && !inlinedType) return;
			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : .());
			let hasDoc = DocString(output, cursor, *newLine, indent);
			if (!hasDoc && *newLine) output.Append('\n');
			if (!inlinedType) output.Append(indent);
			if (includeAttrs) GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), default, output, StringView[?](packed ? "Packed" : ""));
			output.Append(block.HasValue ? " public struct " : " struct "); AddSpelling(cursor, library, output, lastDecls); output.Append("\n", indent, "{\n");
			bool putNewLine = false;
			int bitFieldCurrentBlockSize = 0;
			int bitFieldTotalWidth = 0;
			static void DumpBitfield(String output, int* bitFieldCurrentBlockSize, int* bitFieldTotalWidth, CXCursor uniqueSuffix, StringView doubleIndent)
			{
				output.Append(doubleIndent, "private uint");
				(*bitFieldCurrentBlockSize).ToString(output);
				output.Append(" __bitfield_");
				Clang.GetRangeEnd(Clang.GetCursorExtent(uniqueSuffix)).[Friend]int_data.ToString(output);
				output.Append(";\n");

				*bitFieldCurrentBlockSize = 0;
				*bitFieldTotalWidth = 0;
			}
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				(String output, bool* newLine, StringView doubleIndent, LibraryInfo library, CXTranslationUnit unit, int* bitFieldCurrentBlockSize, int* bitFieldTotalWidth) = *(.)data;
				switch (cursor.kind)
				{
				case .FieldDecl:
					let type = Clang.GetCursorType(cursor);
					if (Clang.Cursor_IsBitField(cursor) != 0)
					{
						let hasDoc = DocString(output, cursor, *newLine, doubleIndent);

						let size = Clang.Type_GetSizeOf(type) * 8;
						if (size > *bitFieldCurrentBlockSize)
							*bitFieldCurrentBlockSize = size;

						let width = Clang.GetFieldDeclBitWidth(cursor);
						if (*bitFieldTotalWidth + width > *bitFieldCurrentBlockSize)
							DumpBitfield(output, bitFieldCurrentBlockSize, bitFieldTotalWidth, cursor, doubleIndent);

						if (String.StrLen(GetString!(Clang.GetCursorSpelling(cursor))) > 0)
						{
							output.Append(doubleIndent, "[Bitfield(.Public, .BitsAt(bits: ");
							width.ToString(output);
							output.Append(", pos: ");
							(*bitFieldTotalWidth).ToString(output);
							output.Append("), \"");
							AddSpelling(cursor, library, output);
							output.Append("\")]\n");
						}

						*bitFieldTotalWidth += width;

						if (hasDoc) output.Append('\n');
						*newLine = !hasDoc;
						return .Continue;
					}

					if (*bitFieldTotalWidth > 0)
						DumpBitfield(output, bitFieldCurrentBlockSize, bitFieldTotalWidth, cursor, doubleIndent);

					let hasDoc = DocString(output, cursor, *newLine, doubleIndent);
					output.Append(doubleIndent);
					GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), type, output);
					output.Append("public ");
					Type(type, output, library);
					output.Append(' '); AddSpelling(cursor, library, output); output.Append(";\n");
					var underlyingType = type;
					findUnderlying: while (true)
						switch (underlyingType.kind)
						{
						case .Pointer:
							underlyingType = Clang.GetPointeeType(underlyingType);
						case .ConstantArray, .IncompleteArray:
							underlyingType = Clang.GetArrayElementType(underlyingType);
						default:
							break findUnderlying;
						}
					if (hasDoc) output.Append('\n');
					*newLine = !hasDoc;
				case .StructDecl, .UnionDecl when Clang.Cursor_IsAnonymous(cursor) != 0:
					bool newLineBuf = false;
					output.Append(doubleIndent);
					GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), default, output);
					output.Append(" public using ");
					Cursor(cursor, output, library, unit, doubleIndent, .Empty, null, &newLineBuf, inlinedType: true);
					output..TrimEnd()..Append(";\n");
					*newLine = false;
				case .StructDecl, .UnionDecl, .EnumDecl when Clang.Cursor_IsAnonymous(cursor) == 0:
					bool newLineBuf = false;
					output.Append(doubleIndent);
					GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), default, output);
					output.Append(" public ");
					Cursor(cursor, output, library, unit, "\t", .Empty, null, &newLineBuf, inlinedType: true);
					output..TrimEnd()..Append('\n');
					*newLine = false;
				default: return .Continue;
				}
				
				return .Continue;
			}, &(output, &putNewLine, doubleIndent, library, unit, &bitFieldCurrentBlockSize, &bitFieldTotalWidth));
			if (bitFieldTotalWidth > 0)
				DumpBitfield(output, &bitFieldCurrentBlockSize, &bitFieldTotalWidth, cursor, doubleIndent);
			if (output.EndsWith("\n\n")) output.RemoveFromEnd(1);
			output.Append(indent, "}\n\n");
			*newLine = false;

		case .EnumDecl:
			bool packed = false;
			Clang.VisitChildren(cursor, (cursor, parent, client_data) =>
			{
				if (cursor.kind != .PackedAttr) return .Continue;
				bool* packed = (.)client_data;
				*packed = true;
				return .Break;
			}, &packed);

			bool anonymous = Clang.Cursor_IsAnonymous(cursor) != 0 && !inlinedType;
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			let block = library.getBlock?.Invoke(cursor, spelling);
			if (anonymous)
			{
				EnsureBlock(block.HasValue ? block.Value : "static");
			}
			else
			{
				EnsureBlock(block.HasValue ? block.Value : .());
				let hasDoc = DocString(output, cursor, *newLine, indent);
				if (!hasDoc && *newLine) output.Append('\n');
				if (!inlinedType) output.Append(indent);
				if (includeAttrs) GetAttributes(cursor, library, spelling, default, output);
				output.Append(block.HasValue ? " public enum " : " enum "); AddSpelling(cursor, library, output, lastDecls);
				if (!packed)
				{
					output.Append(" : ");
					Type(Clang.GetEnumDeclIntegerType(cursor), output, library, true);
				}
				output.Append("\n", indent, "{\n");
			}
			bool putNewLine = false;
			CXString lastDocString = default;
			Clang.VisitChildren(cursor, (cursor, parent, data) =>
			{
				if (cursor.kind != .EnumConstantDecl) return .Continue;
				(String output, bool* newLine, StringView indent, LibraryInfo library, bool anonymous, CXTranslationUnit unit, StringView parentSpelling, CXString* lastDocString) = *(.)data;
				StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
				String toDelete = null;
				library.modifyEnumCaseSpelling?.Invoke(ref spelling, parentSpelling, out toDelete);
				defer delete toDelete;
				bool hasDoc;
				CXString docString = Clang.Cursor_GetRawCommentText(cursor);
				defer
				{
					Clang.DisposeString(*lastDocString);
					*lastDocString = docString;
				}
				if (StringView(Clang.GetCString(*lastDocString)) == StringView(Clang.GetCString(docString)))
					hasDoc = false;
				else
					hasDoc = DocString(output, cursor, *newLine, indent);
				output.Append(indent);
				if (anonymous) output.Append("public static c_int ");
				Compiler.Identifier.GetSourceName(spelling, output);
				output.Append(" = ");
				constExpr: do
				{
					Span<CXToken> tokens;
					{
						CXToken* tokenPtr = null;
						uint32 tokenCount = 0;
						Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokenPtr, &tokenCount);
						defer:constExpr Clang.DisposeTokens(unit, tokenPtr, tokenCount);
						if (tokenCount < 3)
						{
							Clang.GetEnumConstantDeclValue(cursor).ToString(output);
							break;
						}
						tokens = .(tokenPtr, tokenCount)..RemoveFromStart(2);
					}
					CXCursor[] cursors = scope .[tokens.Length];
					Clang.AnnotateTokens(unit, tokens.Ptr, (.)tokens.Length, cursors.Ptr);
					for (let i < tokens.Length)
					{
						if (Clang.GetTokenKind(tokens[i]) != .Identifier)
							continue;
						let parentRange = Clang.GetCursorExtent(parent);
						let definitionRange = Clang.GetCursorExtent(Clang.GetCursorReferenced(cursors[i]));
						if (parentRange.begin_int_data < definitionRange.end_int_data && parentRange.end_int_data > definitionRange.end_int_data)
							continue;
						Clang.GetEnumConstantDeclValue(cursor).ToString(output);
						output.Append(" /* ");
						defer:constExpr output.Append(" */");
						break;
					}
					for (let token in tokens)
					{
						StringView spell = .(GetString!(Clang.GetTokenSpelling(unit, token)));
						switch (Clang.GetTokenKind(token))
						{
						case .Punctuation:
							switch (spell[0])
							{
							case '|', '&', '^', '<', '>', '+', '-', '*', '/':
								output..Append(' ')..Append(spell)..Append(' ');
							case ',':
								output.Append(", ");
							default:
								output.Append(spell);
							}
						case .Identifier:
							library.modifyEnumCaseSpelling?.Invoke(ref spell, parentSpelling, out toDelete);
							output.Append(spell);
							delete toDelete;
						default: output.Append(spell);
						}
					}
				}
				output..Append(anonymous ? ';' : ',')..Append('\n');
				if (hasDoc) output.Append('\n');
				*newLine = !hasDoc;
				return .Continue;
			}, &(output, &putNewLine, (anonymous ? indent : doubleIndent), library, anonymous, unit, spelling, &lastDocString));
			Clang.DisposeString(lastDocString);

			if (output.EndsWith("\n\n")) output.RemoveFromEnd(1);
			if (!anonymous) output.Append(indent, "}\n");
			output.Append('\n');
			*newLine = false;

		case .TypedefDecl:
			StringView spelling = .(GetString!(Clang.GetCursorSpelling(cursor)));
			StringView docs = .(GetString!(Clang.Cursor_GetRawCommentText(cursor)));
			let type = Clang.GetTypedefDeclUnderlyingType(cursor);

			if (lastDecls != null && lastDecls.EndsWith(spelling))
				return;

			let block = library.getBlock?.Invoke(cursor, spelling);
			EnsureBlock(block.HasValue ? block.Value : .());
			let accessMod = block.HasValue ? "public " : "";
			bool hasDoc = false;
			switch (type.kind)
			{
			case .Pointer:
				let pointee = Clang.GetPointeeType(type);
				if (pointee.kind case .FunctionNoProto || pointee.kind case .FunctionProto) funcPtr: do
				{
					hasDoc = DocString(output, cursor, *newLine, indent);
					output.Append(indent);
					attrs:
					{
						StringView[?] attrs = .(library.customFunctionAttributes);
						GetAttributes(cursor, library, spelling, Clang.GetResultType(type), output, attrs);
					}
					output.Append(accessMod, "function ");
					Type(Clang.GetResultType(pointee), output, library);
					if (pointee.kind case .FunctionNoProto || Clang.GetNumArgTypes(pointee) == 0)
					{
						output.Append(" ", spelling, "();\n");
						break;
					}
					output.Append(" ", spelling, "(");
					let argc = Clang.GetNumArgTypes(pointee);
					CXToken* tokens = null;
					uint32 tokenCount = 0;
					Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokens, &tokenCount);
					defer Clang.DisposeTokens(unit, tokens, tokenCount);
					CXSourceLocation currentLoc = Clang.GetRangeStart(Clang.GetTokenExtent(unit, tokens[0]));
					StringView[] paramNames = scope:funcPtr .[argc];
					int paramNamesCount = 0;
					CXTokenKind lastTokenKind = ?;
					StringView lastSpelling = null;
					while (true)
					{
						let token = Clang.GetToken(unit, currentLoc);
						if (token == null) break;
						defer:funcPtr Clang.DisposeTokens(unit, token, 1);
						StringView tokenSpelling = .(GetString!:funcPtr(Clang.GetTokenSpelling(unit, *token)));
						currentLoc = Clang.GetRangeEnd(Clang.GetTokenExtent(unit, *token));
						if (tokenSpelling == ")") break;
					}
					while (true)
					{
						let token = Clang.GetToken(unit, currentLoc);
						if (token == null) break;
						defer:funcPtr Clang.DisposeTokens(unit, token, 1);
						StringView tokenSpelling = .(GetString!:funcPtr(Clang.GetTokenSpelling(unit, *token)));
						if (tokenSpelling == ";") break;
						else if (tokenSpelling == "," || (tokenSpelling == ")" && !lastSpelling.IsNull))
						{
							if (lastTokenKind case .Identifier)
								paramNames[paramNamesCount++] = lastSpelling;
							else
								paramNames[paramNamesCount++] = "";
						}
						lastSpelling = tokenSpelling;
						lastTokenKind = Clang.GetTokenKind(*token);
						currentLoc = Clang.GetRangeEnd(Clang.GetTokenExtent(unit, *token));
					}
					bool[] outParams = scope .[argc];
					let comment = Clang.Cursor_GetParsedComment(cursor);
					FillOutParams(comment, outParams, paramNames);
					StringView prevParamName = "";
					for (let i < argc)
					{
						if (i > 0) output.Append(", ");
						StringView paramName = i < paramNamesCount ? paramNames[i] :
						{
							let childCount = Clang.Comment_GetNumChildren(comment);
							StringView result = "";
							for (let ii < childCount)
							{
								let child = Clang.Comment_GetChild(comment, ii);
								if (Clang.Comment_GetKind(child) != .ParamCommand ||
									Clang.ParamCommandComment_IsParamIndexValid(child) == 0 ||
									Clang.ParamCommandComment_GetParamIndex(child) != ii) continue;
								result = .(GetString!:funcPtr(Clang.ParamCommandComment_GetParamName(child)));
								break;
							}
							result
						};
						var paramType = Clang.GetArgType(pointee, (.)i);
						attrs:
						{
							bool outParam = false;
							if (outParams[i] || IsOutParam(paramType, library, paramName, prevParamName, docs))
							{
								outParam = true;
								paramType = Clang.GetPointeeType(paramType);
							}
							GetAttributes(default, library, null, type, output);
							if (outParam) output.Append("out ");
						}
						Type(paramType, output, library);
						if (!paramName.IsEmpty)
						{
							output.Append(' ');
							Compiler.Identifier.GetSourceName(paramName, output);
						}
						prevParamName = paramName;
					}
					output.Append(");\n");
				}
				else fallthrough;
			default:
				StringView typeStr = Type(type, ..scope .(), library, true);
				if (typeStr == spelling) break;
				hasDoc = DocString(output, cursor, *newLine, indent);
				if (type.kind == .Pointer && library.isHandleUnderlyingOpaque?.Invoke(
						Clang.GetPointeeType(type), .(typeStr)..RemoveFromEnd(1), spelling
					) == true)
				{
					output.Append(indent, "class ", spelling, " { private this() {} }\n");
					break;
				}
				if (library.flags.HasFlag(.VulkanLike) && (typeStr == "VkFlags" || typeStr == "uint32") && lastDecls != null)
				{
					String str = scope:: .(spelling.Length + 4)..Append(';')..Append(spelling)..Replace("Flags", "FlagBits");
					if (lastDecls.Contains(str)) typeStr = str[1...];
				}
				output.Append(indent, accessMod, "typealias ", spelling, " = ", typeStr, ";\n");
			}
			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .VarDecl:
			let type = Clang.GetCursorType(cursor);
			let linkage = Clang.GetCursorLinkage(cursor);

			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);

			switch (linkage)
			{
			case .External:
				output.Append(indent);
				GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), type, output, StringView[?]("CLink"));
				output.Append(" public static extern ");
				Type(type, output, library); output.Append(' ');
				AddSpelling(cursor, library, output, lastDecls); output.Append(";\n");
			case .Internal when Clang.IsConstQualifiedType(type) != 0:
				output.Append(indent);
				GetAttributes(cursor, library, .(GetString!(Clang.GetCursorSpelling(cursor))), type, output);
				output.Append(" public const ");
				Type(type, output, library); output.Append(' ');
				AddSpelling(cursor, library, output, lastDecls); output.Append(" = ");

				CXToken* tokens = null;
				uint32 tokenCount = 0;
				Clang.Tokenize(unit, Clang.GetCursorExtent(cursor), &tokens, &tokenCount);
				defer Clang.DisposeTokens(unit, tokens, tokenCount);
				StringView constValue = .(GetString!(Clang.GetTokenSpelling(unit, tokens[tokenCount-1])));
				if (constValue.EndsWith("ULL") && !constValue.EndsWith("NULL"))
					constValue.RemoveFromEnd(1);
				output.Append(constValue, ";\n");
			default:
			}

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		case .MacroDefinition:
			var extent = Clang.GetCursorExtent(cursor);
			CXToken* tokens = null;
			uint32 tokenCount = 0;
			Clang.Tokenize(unit, extent, &tokens, &tokenCount);
			defer Clang.DisposeTokens(unit, tokens, tokenCount);

			if (tokenCount < 2 || Clang.Cursor_IsMacroFunctionLike(cursor) != 0) return;
			String value = scope .(16);
			let exprType = MacroUtils.WriteTokens(Span<CXToken>(tokens, tokenCount)[1...], unit, value);
			if (exprType case .UnuseableKeywords) return;

			let block = library.getBlock?.Invoke(cursor, .(GetString!(Clang.GetCursorSpelling(cursor))));
			EnsureBlock(block.HasValue ? block.Value : "static");
			let hasDoc = DocString(output, cursor, *newLine, indent);
			output.Append(indent, "public const ");

			switch (exprType)
			{
			case .Unknown, .ProbalePointerCast: output.Append("let");
			case .Numeric: output.Append("c_int");
			case .UnsignedInt: output.Append("uint32");
			case .Floating: output.Append("double");
			case .Float: output.Append("float");
			case .Char: output.Append("c_char");
			case .String: output.Append("c_char*");
			case .UnuseableKeywords: return;
			}
			output.Append(' ');
			AddSpelling(cursor, library, output);
			output.Append(" = ", value, ";\n");

			if (hasDoc) output.Append('\n');
			*newLine = !hasDoc;

		default:
		}
	}
}